	subroutine ReadLineData()
	use GlobalSetup
	use Constants
	IMPLICIT NONE
	integer i,j,i_low,i_up,imol,maxlevels
	real*8 v1,v2
	
	allocate(Mol(nmol))

	do imol=1,nmol
		open(unit=80,file=linefile(imol),RECL=6000)
		read(80,*)
		read(80,*) Mol(imol)%name
		read(80,*)
		read(80,*) Mol(imol)%M
		read(80,*)
		read(80,*) Mol(imol)%nlevels
		read(80,*)
		allocate(Mol(imol)%E(Mol(imol)%nlevels))
		allocate(Mol(imol)%g(Mol(imol)%nlevels))
		do i=1,Mol(imol)%nlevels
			read(80,*) j,Mol(imol)%E(i),Mol(imol)%g(i)
		enddo
		read(80,*)
		read(80,*) Mol(imol)%nlines
		read(80,*)
		allocate(Mol(imol)%L(Mol(imol)%nlines))
		do i=1,Mol(imol)%nlines
			read(80,*) j,Mol(imol)%L(i)%jup,Mol(imol)%L(i)%jlow,Mol(imol)%L(i)%Aul,
     &				Mol(imol)%L(i)%freq,Mol(imol)%E(Mol(imol)%L(i)%jup)	!Mol%L(i)%Eup
			Mol(imol)%L(i)%freq=Mol(imol)%L(i)%freq*1d9
			Mol(imol)%L(i)%lam=clight*1d4/(Mol(imol)%L(i)%freq)
			Mol(imol)%L(i)%imol=imol

			i_low=Mol(imol)%L(i)%jlow
			i_up=Mol(imol)%L(i)%jup
			Mol(imol)%L(i)%Bul=Mol(imol)%L(i)%Aul/(2d0*hplanck*Mol(imol)%L(i)%freq**3/clight**2)
			Mol(imol)%L(i)%Blu=Mol(imol)%L(i)%Bul*Mol(imol)%g(i_up)/Mol(imol)%g(i_low)
		enddo
		close(unit=80)
	enddo

	maxlevels=0
	do imol=1,nmol
		if(Mol(imol)%nlevels.gt.maxlevels) maxlevels=Mol(imol)%nlevels
	enddo
	do i=0,nR
		do j=0,nTheta
			allocate(C(i,j)%npop(nmol,maxlevels))
			allocate(C(i,j)%abun(nmol))
			allocate(C(i,j)%line_width(nmol))
		enddo
	enddo

	if(popfile.ne.' ') 	call ReadPopData()

	if(LTE.or.popfile.eq.' ') call ComputeLTE()
	
	do i=0,nR
		do j=0,nTheta
			do imol=1,nmol
				if(popfile.eq.' ') then
					v1=sqrt(2d0*kb*C(i,j)%Tgas/(mp*Mol(imol)%M))
					v2=0.5d0*sqrt((7.0/5.0)*kb*C(i,j)%Tgas/(mp*2.3))
					C(i,j)%line_width(imol)=sqrt(v1**2+v2**2)
				endif
				if(C(i,j)%line_width(imol).lt.vresolution/vres_mult) C(i,j)%line_width(imol)=vresolution/vres_mult
			enddo
		enddo
	enddo
	
	return
	end
	
	
	
c=========================================================================================
c This subroutine reads in a forMCFOST.fits type of file generated by ProDiMo
c It fills the population levels
c=========================================================================================
	subroutine ReadPopData()
	use GlobalSetup
	use Constants
	IMPLICIT NONE
	integer nvars,ivars,i,j,l,k,naxis,nspec,imol,ipop(nmol),ihdu
	character*7 vars(10),hdu
	real,allocatable :: array(:,:,:,:)
	real*8,allocatable :: array_d(:,:,:,:)
	integer*4 :: status,stat2,stat3,readwrite,unit,blocksize,nfound,group
	integer*4 :: firstpix,nbuffer,npixels,hdunum,hdutype,ix,iz,ilam
	integer*4 :: istat,stat4,tmp_int,stat5,stat6
	real  :: nullval
	real*8  :: nullval_d,tot
	logical*4 :: anynull
	integer*4, dimension(4) :: naxes
	character*80 comment,errmessage
	character*30 errtext
	character*30,allocatable :: popname(:)
	integer prodimo2mcfost_version

	! Get an unused Logical Unit Number to use to open the FITS file.
	status=0

	call ftgiou (unit,status)
	! Open file
	readwrite=0
	call ftopen(unit,popfile,readwrite,blocksize,status)
	if (status /= 0) then
		call output("Population file not found "//trim(popfile))
		call output("==================================================================")
		stop
	endif
	group=1
	firstpix=1
	nullval=-999
	nullval_d=-999

	call output("Reading level populations from: "//trim(popfile))


	call ftgkyj(unit,'prodimo2mcfost',prodimo2mcfost_version,comment,status)
	call output("prodimo2mcfost version: " // trim(int2string(prodimo2mcfost_version,'(i2)')))

	if(prodimo2mcfost_version.ge.4) then
		call ftgkyj(unit,'nspec',nspec,comment,status)
		allocate(popname(nspec))
		do i=1,nspec
		    call ftgkys(unit,'species',popname(i),comment,status)
		enddo
	else
c set default names of the species
		nspec=5
		allocate(popname(nspec))
		popname(1) = "C+"
		popname(2) = "O"
		popname(3) = "CO"
		popname(4) = "o-H2O"
		popname(5) = "p-H2O"
	endif


	do imol=1,nmol
		ipop(imol)=0
		do i=1,nspec
			if(trim(Mol(imol)%name).eq.trim(popname(i))) ipop(imol)=i
		enddo
		if(ipop(imol).eq.0) call output("Cannot find species " // 
     &			trim(Mol(imol)%name) // " in the population file.")
	enddo
	do imol=1,nmol
		if(ipop(imol).eq.0) stop
	enddo

	!------------------------------------------------------------------------
	! HDU0 : grid
	!------------------------------------------------------------------------
	! Skip this, it is already done

	!------------------------------------------------------------------------------
	! HDU 2: Gas Temperature 
	!------------------------------------------------------------------------------

	!  move to next hdu
	call ftmrhd(unit,1,hdutype,status)
	if(status.ne.0) then
		status=0
		goto 1
	endif

	naxis=2

	! Check dimensions
	call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)

	do i=naxis+1,4
		naxes(i)=1
	enddo
	npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)

	! read_image
	allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))

	call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)

	do i=1,nR-1
		do j=1,nTheta
			C(i,j)%Tgas=array_d(i,nTheta+1-j,1,1)
		enddo
	enddo

	deallocate(array_d)
	
	!------------------------------------------------------------------------------
	! HDU 3 : Molecular particle densities [1/cm^3]
	!------------------------------------------------------------------------------

	!  move to next hdu
	call ftmrhd(unit,1,hdutype,status)
	if(status.ne.0) then
		status=0
		goto 1
	endif

	naxis=3

	! Check dimensions
	call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)

	do i=naxis+1,4
		naxes(i)=1
	enddo
	npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)

	! read_image
	allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))

	call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)

	do i=1,nR-1
		do j=1,nTheta
			if(C(i,j)%dens.gt.1d-50) then
				do imol=1,nmol
					C(i,j)%abun(imol)=array_d(ipop(imol),i,nTheta+1-j,1)*Mol(imol)%M*mp/C(i,j)%dens
				enddo
			else
				C(i,j)%abun=1d-4
			endif
		enddo
	enddo

	deallocate(array_d)

	!------------------------------------------------------------------------------
	! HDU 4 : Line broadening parameter
	!------------------------------------------------------------------------------

	!  move to next hdu
	call ftmrhd(unit,1,hdutype,status)
	if(status.ne.0) then
		status=0
		goto 1
	endif

	naxis=3

	! Check dimensions
	call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)

	do i=naxis+1,4
		naxes(i)=1
	enddo
	npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)

	! read_image
	allocate(array_d(naxes(1),naxes(2),naxes(3),naxes(4)))

	call ftgpvd(unit,group,firstpix,npixels,nullval_d,array_d,anynull,status)

	do i=1,nR-1
		do j=1,nTheta
			do imol=1,nmol
				C(i,j)%line_width(imol)=array_d(ipop(imol),i,nTheta+1-j,1)*1d5
			enddo
		enddo
	enddo

	deallocate(array_d)
	
	!------------------------------------------------------------------------------
	! HDU 5... : level populations
	!------------------------------------------------------------------------------

	ihdu=0
2	continue
	
	!  move to next hdu
	call ftmrhd(unit,1,hdutype,status)
	ihdu=ihdu+1
	if(status.ne.0) then
		status=0
		goto 1
	endif

	do imol=1,nmol
		if(ipop(imol).eq.ihdu) exit
	enddo
	if(imol.gt.nmol) goto 2	

	naxis=3

	! Check dimensions
	call ftgknj(unit,'NAXIS',1,naxis,naxes,nfound,status)

	do i=naxis+1,4
		naxes(i)=1
	enddo
	npixels=naxes(1)*naxes(2)*naxes(3)*naxes(4)

	! read_image
	allocate(array(naxes(1),naxes(2),naxes(3),naxes(4)))

	call ftgpve(unit,group,firstpix,npixels,nullval,array,anynull,status)

	call output("Reading from HDU: " // trim(int2string(ihdu,'(i3)')) // ": "  // trim(Mol(imol)%name))
	if(naxes(1).lt.Mol(imol)%nlevels.and..not.LTE) then
		call output("Assuming levels above " // trim(int2string(naxes(1),'(i4)')) // " unpopulated")
	endif

	if(naxes(1).gt.Mol(imol)%nlevels) naxes(1)=Mol(imol)%nlevels
	do i=1,nR-1
		do j=1,nTheta
			C(i,j)%npop(imol,1:Mol(imol)%nlevels)=0d0
			tot=0d0
			do k=1,naxes(1)
				C(i,j)%npop(imol,k)=array(k,i,nTheta+1-j,1)
			enddo
			if(prodimo2mcfost_version.ge.3) then
				do k=2,naxes(1)
					C(i,j)%npop(imol,k)=C(i,j)%npop(imol,k-1)*C(i,j)%npop(imol,k)
				enddo
				tot=sum(C(i,j)%npop(imol,1:Mol(imol)%nlevels))
				C(i,j)%npop(imol,1:Mol(imol)%nlevels)=C(i,j)%npop(imol,1:Mol(imol)%nlevels)/tot
			endif
		enddo
	enddo

	deallocate(array)

	goto 2

1	continue

	!  Close the file and free the unit number.
	call ftclos(unit, status)
	call ftfiou(unit, status)

	!  Check for any error, and if so print out error messages
	!  Get the text string which describes the error
	if (status > 0) then
	   call ftgerr(status,errtext)
	   print *,'FITSIO Error Status =',status,': ',errtext

	   !  Read and print out all the error messages on the FITSIO stack
	   call ftgmsg(errmessage)
	   do while (errmessage .ne. ' ')
		  print *,errmessage
		  call ftgmsg(errmessage)
	   end do
	endif

	do j=1,nTheta
		do imol=1,nmol
			C(0,j)%npop(imol,1:Mol(imol)%nlevels)=C(1,j)%npop(imol,1:Mol(imol)%nlevels)
			C(0,j)%abun(imol)=C(1,j)%abun(imol)
			C(nR,j)%npop(imol,1:Mol(imol)%nlevels)=C(nR-1,j)%npop(imol,1:Mol(imol)%nlevels)
			C(nR,j)%abun(imol)=C(nR-1,j)%abun(imol)
		enddo
	enddo
	do i=0,nR
		do imol=1,nmol
			C(i,0)%npop(imol,1:Mol(imol)%nlevels)=C(i,1)%npop(imol,1:Mol(imol)%nlevels)
			C(i,0)%abun(imol)=C(i,1)%abun(imol)
		enddo
	enddo
	
	deallocate(popname)
	
	return
	end
	


